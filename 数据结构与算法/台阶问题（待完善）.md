### 11.用非递归求第n个斐波那契数

> **斐波那契数：从第三个数开始，后一个数等于前面两个数相加**

```

```



------

### 12.用递归方式求第n个斐波那契数

> ```
> 
> ```

此种写法需要计算很多重复的数，效率低！



> ```
> 
> ```



### 13.青蛙跳台阶问题

> **题目：一只青蛙一次可以跳上1级台阶,也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法(先后次序不同算不同的结果)。 ->可认为是斐波那契数列**

 **根据上面的函数，我们可以很容易写出代码！**

> ```
> #include<stdio.h>
> int Frog_Step(int n)
> {
>     if(n == 0)
>         return 0;
>     else if(n == 1)
>         return 1;
>     else if(n == 2)
>         return 2;
>     else
>         return Frog_Step(n-1)+Frog_Step(n-2);
> }
> 
> int main()
> {
>     int n = 0;
>     scanf("%d",&n);
>     int ret = Frog_Step(n);
>     printf("%d\n",ret);
> }
> ```

###  延深1：一次可以跳3个台阶

> **首先我们让青蛙一次可以跳3个台阶**
>
> **1.当N=1时，有1种方法；**
>
> **2.当N=2时，有2种方法；**
>
> **3.当N=3时，青蛙可以选择第一步先跳1个台阶或者2个台阶或者3个台阶，有（1，1，1），（1，2），（2，1），（3）四种方法；**
>
> **4.当N=4时，青蛙选择第一步跳1层时，剩下3个台阶则时n=3时的方法； 青蛙第一步选择跳2层时，剩下2个台阶则是n=2时的方法；**
>
> **青蛙第一步选择跳3层时，剩下一个台阶则是n=1时的方法；**
>
> **所以当n=4时的所有方法为： n=3的所有方法 + n=2的所有方法 + n=1的所有方法； 以此类推，当N=n时，n层台阶的方法为：n-1 层的方法 + n-2 层的方法 + n-3 的方法；**

```
//一次跳3个台阶
#include<stdio.h>
int frog(int n)
{
    if(n == 1)
    {
        return 1;
    }
    if(n == 2)
    {
        return 2;
    }
    if(n==3)
    {
        return 4;
    }
    return frog(n-1) + frog(n-2) + frog(n-3);
}
int main()
{
    int n;
    scanf("%d",&n);
    int ways = frog(n);
    printf("%d\n",ways);
    return 0;
}
```

------

### 延申2：一次可以跳k层台阶 

> **我们再继续向下延申，若青蛙一次可以跳k层台阶呢？**
>
> 很显然，经过上面的讨论，这个问题已经变得不那么复杂了，我们只需要计算出青蛙在跳 1 层台阶一直到青蛙跳 k 层台阶分别有多少种方法，再利用递归，就会轻而易举的得到结果。  

```
int frog(int n, int k)
{
    if(n == 1)
    {
        return 1;
    }
    if(n == 2)
    {
        return 2;
    }
    .......
    .......
    if(n == k)
    {
        return ?//跳 k 层台阶时的方法
    }
    return frog(n-1) + frog(n-2)+ ........+frog(n-k);
}
```

------

------

## 14.汉诺塔问题

**问题：A上面放的盘子上面小下面大，借助B盘，将A中的盘子移动到C，移动时要保证B,C的盘子都是上面小下面大,要一个一个盘子移动**

> 解决方法：1.把A中的n-1个盘子通过C移动到B
>
> ​         2.把A中的剩余的1个盘子移到C
>
> ​          3.把B中的n-1个盘子，通过A移到C

```
void move(char pos1, char pos2)
{
    printf("%c->%c ", pos1, pos2);
}
/*
n:要移动的盘子数，
pos1：起始位置
pos2：中转位置
pos3：目的位置
*/
void Hanoi(int n, char pos1, char pos2, char pos3)
{
    if (n == 1)
    {
        move(pos1, pos3);	//只有一个盘子，直接从pos1->pos3
    }
    else
    {
        /*(1)以C盘为中介，从A杆将1至n - 1号盘移至B杆；
        (2)将A杆中剩下的第n号盘移至C杆；
        (3)以A杆为中介；从B杆将1至n - 1号盘移至C杆。*/

        Hanoi(n - 1, pos1, pos3, pos2);	//以C盘为中介，从A杆将1至n - 1号盘移至B杆
        move(pos1, pos3);//将A杆中剩下的一个盘移至C杆；
        Hanoi(n - 1, pos2, pos1, pos3);//以A杆为中介；从B杆将1至n - 1号盘移至C杆。
    }
}
int main()
{
    Hanoi(3, 'A', 'B', 'C');
    return 0;
}
```

------

### 总结

> **递归有时候很好用，但我们要进行慎重考虑使用递归会不会带来问题，如栈溢出和死递归情况， 比如第12题的方法1，要计算很多重复的数，计算机效率大大下降，而进行改进后，加法的运行效率更高！**