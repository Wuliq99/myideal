

# 查找

顺序表查找算法

``` c
/* 顺序查找，a为数组，n为要查找的数组长度， key为要查找的关键字 */
int Sequential_Search(int *a, int n, int key)
{ 
    int i;
    for (i = 1; i <= n; i++) 
    {
        if (a[i] == key) 
            return i;
    }
    return 0;
}
```

优化

``` c
/* 有哨兵顺序查找 */ 
int Sequential_Search2(int *a, int n, int key) 
{ 
    int i;
    /* 设置a[0]为关键字值，我们称之为“哨兵” */
    a[0] = key;
	/* 循环从数组尾部开始 */ 
    i = n; 
    while (a[i] != key)
    { 
        i--; 
    }
    /* 返回0则说明查找失败 */ 
    return i;
}

```

> 这种在查找方向的尽头放置“哨兵”免去了在查找过程中每一次比较后都 
>
> 要判断查找位置是否越界的小技巧，看似与原先差别不大，但在总数据 
>
> 较多时，效率提高很大，是非常好的编码技巧。当然，“哨兵”也不一定 
>
> 就一定要在数组开始，也可以在末端。 

## 有序表查找

### 折半查找

> 折半查找（Binary Search）技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺 序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对 象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中 间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间 记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程， 直到查找成功，或所有查找区域无记录，查找失败为止。 

``` c
/* 折半查找 */
int Binary_Search(int *a, int n, int key)
{ 
    int low, high, mid; 
    /* 定义最低下标为记录首位 */ 
    low = 1;
    /* 定义最高下标为记录末位 */ 
    high = n;
    while (low <= high)
    { 
        /* 折半 */ 
        mid = (low + high) / 2; 
        /* 若查找值比中值小 */ 
        if (key < a[mid])
            /* 最高下标调整到中位下标小一位 */ 
            high = mid - 1; 
        /* 若查找值比中值大 */
        else if (key > a[mid])
            /* 最低下标调整到中位下标大一位 */ 
            low = mid + 1;
        else
/* 若相等则说明mid即为查找到的位置 */ 
            return mid; 
    }
    return 0; 
}
```

> 假设我们现在有这样一个有序表数组{0,1,16,24,35,47,59,62,73,88,99}， 除0下标外共10个数字。对它进行查找是否存在62这个数。我们来看折 半查找的算法是如何工作的

### 插值查找

现在我们的新问题是，为什么一定要折半，而不是折四分之一或者折更 多呢？ 打个比方，在英文词典里查“apple”，你下意识里翻开词典是翻前面的书 页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这 里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。

折半查找代码的第8句，我们略微等式变换后得到：
$$
mid=(low+high)/2=low+(high-low)/2
$$
也就是mid等于最低下标low加上最高下标high与low的差的一半。算法 科学家们考虑的就是将这个1/2进行改进，改进为下面的计算方案：
$$
mid=low+(key-a[low])*(high-low)/(a[high]-a[low])
$$
将1/2改成了(key-a[low])/(a[high]-a[low])有什么道理呢？假设a[11]= {0,1,16,24,35,47,59,62,73,88,99}，low=1，high=10，则a[low]=1， a[high]=99，如果我们要找的是key=16时，按原来折半的做法，我们需 要四次（如图8-4-6）才可以得到结果，但如果用新办法，(key- a[low])/(a[high]-a[low])=(16-1)/(99-1)≈0.153，即mid≈1+0.153×(10- 1)=2.377取整得到mid=2，我们只需要二次就查找到结果了，显然大大 提高了查找的效率。 



换句话说，我们只需要在折半查找算法的代码中更改一下第8行代码如 下：

``` c
mid=low+ (high-low)*(key-a[low])/(a[high]-a[low]); /* 插值 */ 
```

就得到了另一种有序表查找算法，插值查找法。

> 插值查找（Interpolation Search）是根据要查找的关键字key与查找表中最大最小记录的关键字比 较后的查找方法，其核心就在于插值的计算公式(key-a[low])/(a[high]- a[low])。应该说，从时间复杂度来看，它也是O(logn)，但对于表长较 大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能 比折半查找要好得多。反之，数组中如果分布类似 {0,1,2,2000,2001,......,999998,999999}这种极端不均匀的数据，用插值查 找未必是很合适的选择。 

### 斐波那契查找 

还有没有其他办法？我们折半查找是从中间分，也就是说，每一次查找 总是一分为二，无论数据偏大还是偏小，很多时候这都未必就是最合理 的做法。除了插值查找，我们再介绍一种有序查找，斐波那契查找（Fibonacci Search），它是利用了黄金分割原理来实现的。 斐波那契数列我们在前面4.8节讲递归时，也详细地介绍了它。如何利用这个数列来作为分割呢？ 

![](C:\Users\HONOR\Desktop\大话数据结构\Snipaste_2021-08-10_16-31-57.png)

下面我们根据代码来看程序是如何运行的。 

```c
/* 斐波那契查找 */
int Fibonacci_Search(int *a, int n, int key) 
{ 
    int low, high, mid, i, k;
    /*定义最低下标为记录首位 */ 
    low = 1; 
    /*定义最高下标为记录末位 */
    high = n;
    k = 0; 
    /* 计算n位于斐波那契数列的位置 */
    while (n > F[k] - 1)
        k++;
    /* 将不满的数值补全 */
    for (i = n; i < F[k] - 1; i++) 
        a[i] = a[n];
    while (low <= high)
    { 
        /* 计算当前分隔的下标 */ 
        mid = low + F[k - 1] - 1; 
        /* 若查找记录小于当前分隔记录 */ 
        if (key < a[mid]) 
        { 
            /* 最高下标调整到分隔下标mid-1处 */
            high = mid - 1;
            /* 斐波那契数列下标减一位 */
            k = k - 1;
        }
        /* 若查找记录大于当前分隔记录 */
        else if (key > a[mid])
        { 
            /* 最低下标调整到分隔下标mid+1处 */
            low = mid + 1; 
            /* 斐波那契数列下标减两位 */ 
            k = k - 2;
        }
        else
        { 
            if (mid <= n)
                /* 若相等则说明mid即为查找到的位置 */ 
                return mid;
            else
/* 若mid>n说明是补全数值，返回n */ 
                return n;
        }
    }
    return 0; 
}
```

> 斐波那契查找算法的核心在于： 
>
> 1）当key=a[mid]时，查找就成功； 
>
> 2）当key<a[mid]时，新范围是第low个到第mid-1个，此时范围个数为 
>
> F[k-1]-1个； 
>
> 3）当key>a[mid]时，新范围是第m+1个到第high个，此时范围个数为 
>
> F[k-2]-1个

也就是说，如果要查找的记录在右侧，则左侧的数据都不用再判断了， 不断反复进行下去，对处于当中的大部分数据，其工作效率要高一些。 所以尽管斐波那契查找的时间复杂也为O(logn)，但就平均性能来说，斐 波那契查找要优于折半查找。可惜如果是最坏情况，比如这里key=1， 那么始终都处于左侧长半区在查找，则查找效率要低于折半查找。 

### 总结

> 还有比较关键的一点，折半查找是进行加法与除法运算（mid=(low＋ high)/2），
>
> 插值查找进行复杂的四则运算（mid=low＋(high-low)*(key- a[low])/(a[high]-a[low])），
>
> 而斐波那契查找只是最简单加减法运算 （mid=low＋F[k-1]-1），
>
> 在海量数据的查找过程中，这种细微的差别可 能会影响最终的查找效率。 
>
> 应该说，三种有序表的查找本质上是分隔点的选择不同，各有优劣，实 
>
> 际开发时可根据数据的特点综合考虑再做出选择。 