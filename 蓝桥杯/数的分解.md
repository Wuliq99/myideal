## 题目

> [数的分解](https://www.lanqiao.cn/problems/606/learning/)

## 题目描述

**本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。**

把 2019 分解成 3 个各不相同的正整数之和，并且要求每个正整数都不包含数字 2 和 4，一共有多少种不同的分解方法？

注意交换 3 个整数的顺序被视为同一种方法，例如 1000+1001+18 和 1001+1000+18 被视为同一种。

### 运行限制

- 最大运行时间：1s
- 最大运行内存: 128M

## 题目分析

​		首先，分析题意可得：2019 分解为 3 个**各不相同**的**正整数**之和，且交换顺序视作相同，那么可以使用三个for循环进行枚举，从而得出正确答案。但直接进行暴力枚举效率太低，尤其是当数据量很大时。所以可以进行以下优化：

​		要将 2019 分解为3个 **各不相同**的**正整数**之和，那么必定有最小值、次大值、最大值。则可以判断出各值的最大可能取值：

- 最小值能取到的最大可能的值为 2019/3-1=672（如果为 2019/3=673，则没有最小值），又因为 672 含有数字2，所以应当再往前推一个数取671
- 次大值能取到的最大可能的值是（2019-1）/2-1=1008（若为 2019/2=1009，那么最大值只能为 1010，最小值为0，违反题意）
- 最大值取值可由前两个值求得，只需要判断是否符合条件即可

## 代码实现

```c
#include <stdio.h>
#include <stdlib.h>

int judge(int n) {
    while (n) {
        if (n % 10 == 2 || n % 10 == 4) {
            return 0;
        }
        n /= 10;
    }
    return 1;
}

int main(int argc, char *argv[]) {
    int i, j, k;
    int ans = 0;
    for (i = 1; i <= 671; i++) {
        for (j = i + 1; j <= 1008; j++) {
            k = 2019 - i - j;
            if (judge(i) && judge(j) && judge(k)) {
                if (k > j) {
                    ans++;
                }
            }
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

