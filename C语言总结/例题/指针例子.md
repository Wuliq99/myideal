``` c
#include <stdio.h>
int a = 3, b = 4;
int main() {
    printf("%d\n", a+ +b);
    return 0;
}
```

> 【运行结果】7
> 【结果答疑】原因就是因为加了空格以后，他就把`+`理解成`b`的前缀了，也就是`+b`和`b`等价，这样一来。



``` c
#include <stdio.h>
int a = 6;
int main() {
    printf("%d\n", *&a );
    return 0;
}
```

> 【运行结果】6
> 【结果答疑】这个例子的含义是为了说明`*`和`&`是互逆的关系：`&`是取变量的地址，`*`是根据变量地址取值，而地址又叫指针，所以`*`又叫解指针，也可以叫解引用。



``` c
#include <stdio.h>
int a = 7;
int *fun(int *p) {
    return p;
}
int main() {
    printf("%d\n", *fun(&a));
    return 0;
}
```

> 【运行结果】7
> 【结果答疑】这段代码将全局变量的地址作为函数传参传到函数中，然后再返回出来，再解引用得到全局变量的值。这里想说明的是`int *fun(...)`是一个指针函数，即返回`int *`的函数，所以它等价于`int *(fun(...))`，因为`()`的优先级高于指针运算符`*`。



``` c
#include <stdio.h>
int a[2] = {3, 4};
int main() {
    printf("%d %d\n", &a[1], &(a[1]) );
    return 0;
}
```

> 【运行结果】两个相同的值
> 【结果答疑】得到的是两个相同的值，这里简单解释一下，就是因为[]的优先级比&高，&a[1]相当于取数组的第1个元素后再取地址，相当于基地址a加四个字节（int的大小是4个字节）；但是(&a)[1]相当于先取地址变成了指针，指针在目前64位机器上是8个字节的，再进行一次下标运算，相当于基地址a加8个字节，完美!

``` c
#include <stdio.h>
int a[2] = {3, 4};
int main() {
    printf("%p %p\n", a, &*a );
    return 0;
}
```

> 【运行结果】两个相同的值
> 【结果答疑】这个例子是进一步说明数组的首地址，就是指针指向的位置，`a`代表数组首地址，对首地址解引用，得到的就是`a[0]`，然后再取地址`&`，得到的就是数组`a`的首地址了



``` c
#include <stdio.h>
int a = 5;
int main() {
    printf("%p %p\n", &a, &a + 1);
    return 0;
}
```

> 【运行结果】两个相差4的地址
> 【结果答疑】这个例子说明几个问题：首先，指针是可以进行加法运算的，并且不是作为整数来进行加法运算，指针的加1，相当于按照指针指向的类型偏移对应的单位，且取地址`&`的优先级高于加号`+`。



``` c
#include <stdio.h>
int a[5] = {9, 8, 7, 6, 5};
int main() {
    int *p = a;
    printf("%d\n", *p++);
    return 0;
}
```

> 【运行结果】9
> 【结果答疑】这个例子中，`*`和`++`的优先级是相同的，但是无奈这两个的结合性是从右到左的，所以它等价于`*(p++)`，而且`p++`表达式的值等于`p`。所以最后解引用的还是数组的第一个元素。

``` c
#include <stdio.h>
int a[5] = {9, 8, 7, 6, 5};
int main() {
    int *p = a;
    printf("%d\n", *++p);
    return 0;
}
```

> 【运行结果】8
> 【结果答疑】这个例子是用来类比上面例子的，它输出则是数组的第2个元素的值。

------

``` c
#include <stdio.h>
int a[5] = {9, 8, 7, 6, 5};
int main() {
    int *p = a;
    printf("%d\n", *p<<1);
    return 0;
}
```

> 【运行结果】18
> 【结果答疑】这个例子中，解引用`*`的优先级高于左移运算符`<<`。

------

``` c
#include <stdio.h>

int main() {
    printf("%d\n", 1 << 3 - 1);
    return 0;
}
```

> 【运行结果】4
> 【结果答疑】`1 << 3 - 1`等价于`1 << (3 - 1)`，因为算术运算符的优先级高于移位运算符。

------

```  c
#include <stdio.h>
int a[5] = {9, 8, 7, 6, 5};
int main() {
    int *p = a;
    printf("%d\n", *p>>1);
    return 0;
}
```

> 【运行结果】4
> 【结果答疑】这个例子中，解引用`*`的优先级高于右移运算符`>>`。

------

```c
#include <stdio.h>
int main() {
    printf("%d\n", 1<<1>>1<<1>>1);
    return 0;
}
```

> 【运行结果】1
> 【结果答疑】这个例子中，左移运算符`<<`和左移运算符`>>`的优先级优先级相同，结合性从左到右。

------

``` c
#include <stdio.h>
int main() {
    printf("%d\n", 1 < 1 << 2);
    return 0;
}
```

> 【运行结果】1
> 【结果答疑】左移运算符`<<`的优先级高于关系运算符`<`。