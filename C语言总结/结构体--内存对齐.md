# 内存对齐

> 我们知道，整型变量有自己的大小，浮点型变量有自己的大小，数组也有自己的大小，那么结构体有没有自己的大小呢？回答是肯定的，结构体也有自己的大小，但是结构体的大小并不是简单地将每个结构体成员的大小相加就能得到。由此引发了一个问题--内存对齐。



## 原因

我们都知道计算机是以字节（Byte）为单位划分的，理论上来说CPU是可以访问任一编号的字节数据的，我们又知道CPU的寻址其实是通过地址总线来访问内存的，CPU又分为32位和64位，在32位的CPU一次可以处理4个字节（Byte）的数据，那么CPU实际寻址的步长就是4个字节，也就是只对编号是4的倍数的内存地址进行寻址。同理64位的CPU的寻址步长是8字节，只对编号是8的倍数的内存地址进行寻址,如下图所示是64位CPU的寻址示意图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/ebf4ff333c2f423fb96de0c7e40984f4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzU0MTY3ODkx,size_16,color_FFFFFF,t_70#pic_center)


这样做可以实现最快速的方式寻址且不会遗漏一个字节，也不会重复寻址。

那么对于程序而言，一个变量的数据存储范围是在一个寻址步长范围内的话，这样一次寻址就可以读取到变量的值，如果是超出了步长范围内的数据存储，就需要读取两次寻址再进行数据的拼接，效率明显降低了。例如一个double类型的数据在内存中占据8个字节，如果地址是8，那么好办，一次寻址就可以了，如果是20呢，那就需要进行两次寻址了。这样就产生了数据对齐的规则，也就是将数据尽量的存储在一个步长内，避免跨步长的存储，这就是内存对齐。在32位编译环境下默认4字节对齐，在64位编译环境下默认8字节对齐。


## 结构体内存对齐规则

**对齐规则：**

- 第一个成员在与结构体变量偏移量为0的地址处。（即结构体的首地址处，即对齐到0处）
- 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
- 结构体的总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。
- 如果嵌套了结构体，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。
  

**求对齐数的公式**

> 对齐数 = 该结构体成员变量自身的大小与编译器默认的一个对齐数的较小值。

## 示例

注：VS中的默认对齐数为8，不是所有编译器都有默认对齐数，当编译器没有默认对齐数的时候，成员变量的大小就是该成员的对齐数。

**结构体大小计算步骤：**

```c
struct S
{
	double d;
	char c;
	int i;
};
```

**第一步：找出每个成员变量的大小将其与编译器的默认对齐数相比较，取其较小值为该成员变量的对齐数。**

![在这里插入图片描述](https://img-blog.csdnimg.cn/a0600b595bfa4839a961c9060947d879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzU0MTY3ODkx,size_16,color_FFFFFF,t_70#pic_center)


**第二步：根据每个成员对应的对齐数画出它们在内存中的相对位置。**

![在这里插入图片描述](https://img-blog.csdnimg.cn/f8b90224b58c4825a3215c99bc6bc7c2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzU0MTY3ODkx,size_16,color_FFFFFF,t_70#pic_center)


**第三步：通过最大对齐数决定最终该结构体的大小。**

通过图我们可以知道，绿色部分（double d成员占用）+红色部分（char c成员占用）+紫色部分（int i成员占用）+红色与紫色之间的白色部分（浪费掉了）总共占用了16个字节的内存空间。
我们需要将它们总共占用的内存空间（16）与结构体成员的最大对齐数（8）相比较，结构体的总大小为最大对齐数的整数倍，此时16正好是8的整数倍，所以该结构体在VS编译器下的大小就16个字节。即创建一个该类型的结构体变量，内存需为其开辟16个字节的内存空间。

**注意：**

> 大多数情况下，成员变量已经占用的总字节个数并不一定正好为其成员变量中的最大对齐数的整数倍，这时我们需要将其扩大为最大对齐数的整数倍。

------

## 设计结构体时的技巧

其实在我们设计结构体的时候，如果结构体成员的顺序设计得合理的话，是可以避免不必要的内存消耗的。

### 方法一：

两个结构体的成员变量相同，但是成员变量的顺序不同，可能就会出现结构体的大小不同的情况：


```c
struct S1
{
	char a;
	char b;
	int c;
};//结构体1
struct S2
{
	char a;
	int c;
	char b;
};//结构体2

```

我们可以看到，结构体1和结构体2的成员变量一模一样，可是当我们按照内存对齐规则来计算两个结构体的大小的时候，会发现两个结构体的大小不一样，在VS编译器下第一个结构体大小为8，第二个结构体大小为12。

可以见得，结构体成员变量的顺序不同，可能会造成内存不必要的损失。将占用空间小的成员尽量集中在一起，可以有效地避免内存不必要的浪费。

### 方法二：

修改默认对齐数
要修改编译器的默认对齐数，我们需要借助于以下预处理命令：

```c
#pragma pack()
```

如果在该预处理命令的括号内填上数字，那么默认对齐数将会被改为对应数字；如果只使用该预处理命令，不在括号内填写数字，那么会恢复为编译器默认的对齐数。

```c
#include <stdio.h>

#pragma pack(4)//设置默认对齐数为4
struct S1
{
	char a;//1/4->1
	int b;//4/4->4
	char c;//1/4->1
};//12
#pragma pack()//取消设置的默认对齐数，还原为默认

#pragma pack(1)//设置默认对齐数为1
struct S2
{
	char a;//1/1->1
	int b;//4/1->1
	char c;//1/1->1
};//6
#pragma pack()//取消设置的默认对齐数，还原为默认

int main()
{
	printf("%d\n", sizeof(struct S1));//打印结果为12
	printf("%d\n", sizeof(struct S2));//打印结果为6
	return 0;
}

```



参考：

> https://blog.csdn.net/zhw521411/article/details/105153812
>
> https://blog.csdn.net/chenlong_cxy/article/details/114332324