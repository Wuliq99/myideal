***6174数学黑洞 
取任何一个4位数（4个数字均为同一个数字的例外），将组成该数的4个数字重新组合成可能的最大数和
可能的最小数，再将两者的差求出来；对此差值重复同样的过程（例如：开始时取数8028，最大的重新组
合数为8820，最小的为0288，二者的差8532。重复上述过程得出8532－2358=6174），最后总是达到卡普
雷卡尔黑洞：6174。称之“黑洞”是指再继续运算，都重复这个数，“逃”不出去。把以上计算过程称
为卡普雷卡尔运算，这个现象称归敛，其结果6174称归敛结果。***

```c
#include<stdio.h>

int a[4];

int sort_up(){
	int x;
	int temp;
	int flag=1;
	for(int i=0;i<3;i++){		//升序排列 
	for(int j=0;j<3-i;j++){
		if(a[j]>a[j+1]){
			temp=a[j];
			a[j]=a[j+1];
			a[j+1]=temp;
		
			}
		}
	
	}
	x=a[0]*1000+a[1]*100+a[2]*10+a[3];
	return x;
}

void split(int s){
	a[0] = s/1000;  //把这个数放入数组
    a[1] = s%1000/100;
    a[2] = s%100/10;
    a[3] = s%10;
}

int sort_down(){
	int x;
	int temp;
	int flag=1;
	for(int i=0;i<3;i++){
	for(int j=0;j<3-i;j++){
		if(a[j]<a[j+1]){			//降序排列 
			temp=a[j];
			a[j]=a[j+1];
			a[j+1]=temp;
		
			}
		}
	
	}
	x=a[0]*1000+a[1]*100+a[2]*10+a[3];
	return x;
}
int main(){
	int temp,a1,a2,ans;
	printf("请输入数字：");
	scanf("%d",&ans);
	
	while(1){
	split(ans);
	a2=sort_up();
	a1=sort_down();
	ans=a1-a2;
	printf("%d %d\n",a1,a2);
	if(6174==ans){
		printf("don't escape");
		break;
		}
	}
	
	printf("escape successfully");
}

/*
6174数学黑洞 

取任何一个4位数（4个数字均为同一个数字的例外），将组成该数的4个数字重新组合成可能的最大数和
可能的最小数，再将两者的差求出来；对此差值重复同样的过程（例如：开始时取数8028，最大的重新组
合数为8820，最小的为0288，二者的差8532。重复上述过程得出8532－2358=6174），最后总是达到卡普
雷卡尔黑洞：6174。称之“黑洞”是指再继续运算，都重复这个数，“逃”不出去。把以上计算过程称
为卡普雷卡尔运算，这个现象称归敛，其结果6174称归敛结果。


*/
```